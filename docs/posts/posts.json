[
  {
    "path": "posts/2021-07-08-nmeros-aleatorios/",
    "title": "Números aleatorios",
    "description": "Generación de números aleatorios",
    "author": [
      {
        "name": "Tex",
        "url": {}
      }
    ],
    "date": "2021-07-05",
    "categories": [],
    "contents": "\nUna de las funciones posibles en R es la generación de números aleatorios, los resultados pueden concatenarse y almacenarse en forma de vector.\nNúmeros aleatorios enteros\nEl comando sample nos permite seleccionar/generar números aleatorios enteros.\n\n\naleatorios <- sample(25:40, 25, replace = T)\n\n\n\nEl primer argumento es un vector de números válidos a partir de los cuáles se generarán los valores aleatorios, en este caso van de 25 a 40. El segundo argumento indica el número de valores aleatorios a generar, que para este ejemplo serán 25 números aleatorios. El tercer argumento replace = T indica que cada valor aleatorio puede tener duplicados. Finalmente el resultado es guardado en el objeto de nombre aleatorios.\nRevisamos el resultado\n\n\naleatorios\n\n\n [1] 40 38 38 39 37 27 25 32 40 38 29 40 33 32 31 38 31 30 29 32 39 32\n[23] 38 29 32\n\nGeneración aleatoria de valores de tipo carácter\nTambién es posible seleccionar y/o generar valores aleatorios de tipo carácter, para ello necesitamos en el primer argumento un vector con datos válidos a seleccionar, como segundo argumento el total de valores a generar y definir si se permiten duplicados.\n\n\naleat_txt <- sample(c(\"pera\", \"manzana\", \"guayaba\", \"papaya\", \"mango\"), 25, replace = TRUE)\naleat_txt\n\n\n [1] \"pera\"    \"guayaba\" \"manzana\" \"pera\"    \"pera\"    \"guayaba\"\n [7] \"mango\"   \"pera\"    \"guayaba\" \"guayaba\" \"pera\"    \"manzana\"\n[13] \"manzana\" \"guayaba\" \"guayaba\" \"guayaba\" \"mango\"   \"pera\"   \n[19] \"manzana\" \"pera\"    \"pera\"    \"manzana\" \"pera\"    \"guayaba\"\n[25] \"guayaba\"\n\nNúmeros aleatorios con decimales\nEl comando runif nos permite generar números aleatorios a partir de la distribución uniforme. Aquí un ejemplo para generar 25 números aleatorios entre 12.7 y 24.6\n\n\naleat_unif <- runif(25, 12.7, 24.6)\naleat_unif\n\n\n [1] 14.75986 16.03638 13.87572 17.46015 14.12836 21.84241 12.98478\n [8] 17.68866 15.35246 17.86205 18.19395 22.37742 17.40034 15.06586\n[15] 22.56367 15.73015 16.93628 19.64093 12.90821 17.09079 24.05965\n[22] 16.30991 21.46198 21.85187 17.22264\n\nPara redondear los resultados debemos agregar el comando round y especificar el redondeo a 1 dígito\n\n\naleat_unif <- round(runif(25, 12.7, 24.6), 1)\naleat_unif\n\n\n [1] 23.5 21.3 15.2 16.9 20.8 21.4 15.4 18.3 22.5 20.7 18.3 19.9 21.8\n[14] 19.2 14.5 13.6 17.0 17.7 14.6 15.3 13.0 22.3 24.1 22.3 19.7\n\nEl comando rnorm nos permite generar números aleatorios a partir de la distribución normal. Aquí un ejemplo para generar 25 números aleatorios con media 24.7 y desviación estándar de 4.3\n\n\naleat_rnorm <- rnorm(25, 24.7, 4.3)\naleat_rnorm\n\n\n [1] 23.02697 28.02960 28.20441 22.61868 17.86497 19.59109 27.45181\n [8] 28.66944 20.47103 24.58868 22.33852 19.84454 31.63031 27.53721\n[15] 42.09112 22.31958 21.73012 26.75551 19.89303 22.58814 25.47503\n[22] 27.84191 23.78813 21.08994 31.93298\n\nPara redondear podemos utilizar nuevamente el comando round\n\n\naleat_rnorm <- round(rnorm(25, 24.7, 4.3), 1)\naleat_rnorm\n\n\n [1] 21.8 28.4 21.1 25.9 26.5 26.0 15.8 25.3 26.4 27.3 23.7 21.9 28.7\n[14] 21.8 21.1 24.5 27.2 28.6 21.7 22.8 29.8 26.8 24.5 25.6 26.7\n\n\n\n\n",
    "preview": {},
    "last_modified": "2021-07-08T15:42:10-05:00",
    "input_file": {}
  },
  {
    "path": "posts/2021-07-08-trabajando-con-factores-en-r/",
    "title": "Trabajando con factores en R",
    "description": "Ejemplos básicos para la creación de factores.",
    "author": [
      {
        "name": "Tex",
        "url": {}
      }
    ],
    "date": "2021-07-05",
    "categories": [],
    "contents": "\nUna tarea recurrente cuando trabajamos en el procesamiento de datos, es la transformación de variables para ajustarlas al formato adecuado para su posterior análisis, tal es el caso de variables que pueden estar en formato numérico o de texto y que contienen datos de categorías que necesitamos procesar. R nos permite almacenar una variable con codificación de tipo factor que indica que los valores que la conforman son categorías, por ejemplo: sexo (hombre, mujer), estado civil(soltero, casado), etc. En este post intentaremos dar un vistazo simple a lo que esto significa.\n \nCargamos las librerías a utilizar\n\n\nlibrary(dplyr)\nlibrary(stringr)\n\n\n\nGeneremos una tabla de ejemplo usando una semilla para la reproducibilidad de resultados.\n\n\nset.seed(1234)\n\ntabla <- \n  tibble(id = str_c(\"folio_\", 1:10), \n         sexo = sample(c(1L, 2L), 10, replace = TRUE), \n         edo_civ = sample(c(1L, 2L, 3L), 10, replace = TRUE), \n         ent = sample(c(\"edo1\", \"edo2\", \"edo3\"), 10, replace = TRUE)) %>% \n  print()\n\n\n# A tibble: 10 x 4\n   id        sexo edo_civ ent  \n   <chr>    <int>   <int> <chr>\n 1 folio_1      2       2 edo1 \n 2 folio_2      2       3 edo3 \n 3 folio_3      2       2 edo3 \n 4 folio_4      2       2 edo3 \n 5 folio_5      1       2 edo1 \n 6 folio_6      2       3 edo2 \n 7 folio_7      1       2 edo1 \n 8 folio_8      1       2 edo2 \n 9 folio_9      1       2 edo2 \n10 folio_10     2       2 edo3 \n\nDemos un vistazo a la estructura de la tabla\n\n\nglimpse(tabla)\n\n\nRows: 10\nColumns: 4\n$ id      <chr> \"folio_1\", \"folio_2\", \"folio_3\", \"folio_4\", \"folio_5…\n$ sexo    <int> 2, 2, 2, 2, 1, 2, 1, 1, 1, 2\n$ edo_civ <int> 2, 3, 2, 2, 2, 3, 2, 2, 2, 2\n$ ent     <chr> \"edo1\", \"edo3\", \"edo3\", \"edo3\", \"edo1\", \"edo2\", \"edo…\n\nLas columnas sexo, edo_civ y ent contienen valores que categorizan la información, la tabla las tiene codificadas como numéricas. Generemos medidas de resumen de la tabla y veamos las implicaciones de considerarlas como numéricas\n\n\nsummary(tabla)\n\n\n      id                 sexo        edo_civ        ent           \n Length:10          Min.   :1.0   Min.   :2.0   Length:10         \n Class :character   1st Qu.:1.0   1st Qu.:2.0   Class :character  \n Mode  :character   Median :2.0   Median :2.0   Mode  :character  \n                    Mean   :1.6   Mean   :2.2                     \n                    3rd Qu.:2.0   3rd Qu.:2.0                     \n                    Max.   :2.0   Max.   :3.0                     \n\nComo podemos observar, el resultado previo nos muestra los resultados de las columnas sexo y edo_civ como variables numéricas y a la columna ent como caracter. Sobra decir que resulta extraño tener cuartiles de la variable sexo cuando sólo contiene valores “1” y “2” que corresponden a “hombre” y “mujer” respectivamente, sería más conveniente si obtuvieramos las frecuencias para cada uno de los sexos codificados en la tabla.\nPara resolver esto podemos hacer uso de la transformción de la columna de numérica a factor. Un factor en R otorga niveles a cada una de las categorías existentes en una variable, en el caso de la variable sexo de nuestro ejemplo, tenemos dos niveles que corresponden a los valores codificados como 1 y 2. Además, podemos especificar etiquetas para cada uno de los niveles de nuestro factor.\n \nGenerar un factor sin especificar niveles y etiquetas\nPodemos convertir una variable a factor sin necesidad de especificar los niveles que la conforman, sólo es necesario especificar dentro del comando factor a la variable a transformar.\n¿qué es lo que sucede?\nR se encargará de identificar los distintos valores dentro de la columna y establecerá de forma automática cada uno como un nivel. En el ejemplo siguiente, convertimos a la variable ent a tipo factor y la sobreescribimos bajo el mismo nombre en la tabla.\n\n\ntabla <- tabla %>% mutate(ent = factor(ent)) %>% print()\n\n\n# A tibble: 10 x 4\n   id        sexo edo_civ ent  \n   <chr>    <int>   <int> <fct>\n 1 folio_1      2       2 edo1 \n 2 folio_2      2       3 edo3 \n 3 folio_3      2       2 edo3 \n 4 folio_4      2       2 edo3 \n 5 folio_5      1       2 edo1 \n 6 folio_6      2       3 edo2 \n 7 folio_7      1       2 edo1 \n 8 folio_8      1       2 edo2 \n 9 folio_9      1       2 edo2 \n10 folio_10     2       2 edo3 \n\nNuevamente ejecutamos el comando summary() y vemos el cambio en el resultado, ahora obtendremos la frecuencia de cada uno de los niveles en la malla de datos.\n\n\nsummary(tabla)\n\n\n      id                 sexo        edo_civ      ent   \n Length:10          Min.   :1.0   Min.   :2.0   edo1:3  \n Class :character   1st Qu.:1.0   1st Qu.:2.0   edo2:3  \n Mode  :character   Median :2.0   Median :2.0   edo3:4  \n                    Mean   :1.6   Mean   :2.2           \n                    3rd Qu.:2.0   3rd Qu.:2.0           \n                    Max.   :2.0   Max.   :3.0           \n\n \nGenerar un factor especificando los niveles\nTambién podemos generar un factor especificando los distintos niveles que lo componen, utilicemos el caso de la variable sexo para ejemplificarlo. La variable sexo está codificada con valores 1 y 2, en consecuencia podemos especificar dichos niveles al momento de transformar la variable sexo a factor.\n\n\ntabla <- \n  tabla %>% \n  mutate(sexo = factor(sexo, levels = c(1, 2))) %>% \n  print()\n\n\n# A tibble: 10 x 4\n   id       sexo  edo_civ ent  \n   <chr>    <fct>   <int> <fct>\n 1 folio_1  2           2 edo1 \n 2 folio_2  2           3 edo3 \n 3 folio_3  2           2 edo3 \n 4 folio_4  2           2 edo3 \n 5 folio_5  1           2 edo1 \n 6 folio_6  2           3 edo2 \n 7 folio_7  1           2 edo1 \n 8 folio_8  1           2 edo2 \n 9 folio_9  1           2 edo2 \n10 folio_10 2           2 edo3 \n\nNuevamente visualizamos el summary de la tabla y veremos el resultado con las frecuencias para cada nivel\n\n\nsummary(tabla)\n\n\n      id            sexo     edo_civ      ent   \n Length:10          1:4   Min.   :2.0   edo1:3  \n Class :character   2:6   1st Qu.:2.0   edo2:3  \n Mode  :character         Median :2.0   edo3:4  \n                          Mean   :2.2           \n                          3rd Qu.:2.0           \n                          Max.   :3.0           \n\n \nGenerar un factor especificando niveles y etiquetas\nTambién podemos generar factores especificando, además de los niveles, una etiqueta para cada nivel, por ejemplo, la variable edo_civ codifica valores 1, 2 y 3 que corresponden a “soltero”, “casado” y “divorciado” respectivamente. A partir de esta información, podemos transformar la variable edo_civ a factor, especificando los niveles que contiene y sus respectivas etiquetas.\n\n\ntabla <- \n  tabla %>% \n  mutate(edo_civ = factor(edo_civ, \n                          levels = c(1, 2, 3), \n                          labels = c(\"soltero\", \"casado\", \"divorciado\"))) %>% \n  print()\n\n\n# A tibble: 10 x 4\n   id       sexo  edo_civ    ent  \n   <chr>    <fct> <fct>      <fct>\n 1 folio_1  2     casado     edo1 \n 2 folio_2  2     divorciado edo3 \n 3 folio_3  2     casado     edo3 \n 4 folio_4  2     casado     edo3 \n 5 folio_5  1     casado     edo1 \n 6 folio_6  2     divorciado edo2 \n 7 folio_7  1     casado     edo1 \n 8 folio_8  1     casado     edo2 \n 9 folio_9  1     casado     edo2 \n10 folio_10 2     casado     edo3 \n\nVeamos nuevamente el summary() en dónde obtendremos, al igual que los casos anteriores, las frecuencias de cada uno de los niveles. Note que ahora los valores 1,2 y 3 fueron sustituidos de la tabla por las respectivas etiquetas.\n\n\nsummary(tabla)\n\n\n      id            sexo        edo_civ    ent   \n Length:10          1:4   soltero   :0   edo1:3  \n Class :character   2:6   casado    :8   edo2:3  \n Mode  :character         divorciado:2   edo3:4  \n\nHasta aquí la gestión básica de factores…\n\n\n\n",
    "preview": {},
    "last_modified": "2021-07-10T03:56:40-05:00",
    "input_file": {}
  }
]
